package com.hexagon.game.graphics.screens.myscreens;

import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.hexagon.game.graphics.screens.HexagonScreen;
import com.hexagon.game.graphics.screens.ScreenManager;
import com.hexagon.game.graphics.screens.ScreenType;
import com.hexagon.game.graphics.screens.myscreens.game.GameManager;
import com.hexagon.game.graphics.ui.UILabel;
import com.hexagon.game.map.HexMap;
import com.hexagon.game.map.JsonHexMap;
import com.hexagon.game.map.MapManager;
import com.hexagon.game.map.generator.GeneratorCallback;
import com.hexagon.game.map.generator.MapGenerator;
import com.hexagon.game.map.generator.TileGenerator;
import com.hexagon.game.map.structures.Structure;
import com.hexagon.game.map.structures.StructureCity;
import com.hexagon.game.map.structures.StructureType;
import com.hexagon.game.map.structures.resources.ResourceType;
import com.hexagon.game.map.structures.resources.StructureResource;
import com.hexagon.game.map.tiles.Biome;
import com.hexagon.game.map.tiles.Tile;
import com.hexagon.game.network.packets.PacketMapUpdate;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.UUID;

/**
 * Created by Sven on 14.12.2017.
 */

/**
 * Draws the Hexagonal Map generated by the mapgenerator
 */
public class ScreenGenerator extends HexagonScreen {

    private SpriteBatch batch;
    private BitmapFont font;

    public ScreenGenerator() {
        super(ScreenType.GENERATOR);
    }

    private List<TileGenerator> setupBiomeGenerator(final MapGenerator mapGenerator){

        // Tile Generators
        final List<TileGenerator> generators = new ArrayList<>();

        //biomeGenerator
        generators.add(new TileGenerator() {
            @Override
            public Tile generate(List<Tile> generatedTiles, Tile tile, int x, int y, Random random) {
                if (x == 0 && y == 0) {
                    return tile;
                }
                Biome biomeLast;
                if (y > 0) {
                    biomeLast = mapGenerator.getGeneratedTiles()[x][y - 1].getBiome();
                } else {
                    biomeLast = mapGenerator.getGeneratedTiles()[x - 1][y].getBiome();
                }
                if (biomeLast != Biome.WATER
                        && biomeLast != Biome.ICE
                        && random.nextInt(100) < 20) {
                    tile.setBiome(biomeLast);
                } else {
                    int r = random.nextInt(2);
                    if (r == 0) {
                        tile.setBiome(Biome.DESERT);
                    } else if (r == 1) {
                        tile.setBiome(Biome.PLAINS);
                    }
                }
                return tile;
            }
        });

        // Add the ice generator last! Highest Priority == called last
        //iceGenerator
        generators.add( new TileGenerator() {
            @Override
            public Tile generate(List<Tile> generatedTiles, Tile tile, int x, int y, Random random) {
                if (x < 5 || x > mapGenerator.getSizeX() - 5) {
                    if (x <= 2 || x >= mapGenerator.getSizeX() - 2) {
                        tile.setBiome(Biome.ICE);
                    } else if (tile.getBiome() != Biome.ICE){
                        tile.setBiome(Biome.WATER);
                    }
                }
                if (y < 5 || y > mapGenerator.getSizeY() - 5) {
                    if (y <= 2 || y >= mapGenerator.getSizeY() - 2) {
                        tile.setBiome(Biome.ICE);
                    } else if (tile.getBiome() != Biome.ICE){
                        tile.setBiome(Biome.WATER);
                    }
                }

                return tile;
            }
        });

        //resourceGenerator
        generators.add( new TileGenerator() {
            @Override
            public Tile generate(List<Tile> generatedTiles, Tile tile, int x, int y, Random random) {
                if (tile.getBiome() != Biome.PLAINS) {
                    return tile;
                }
                if (tile.getStructure() != null) {
                    return tile;
                }
                if (random.nextInt(100) <= 20) {
                    int r = random.nextInt(ResourceType.values().length - 1);
                    ResourceType resourceType = ResourceType.values()[r];
                    tile.setStructure(new StructureResource(resourceType));
                }
                return tile;
            }
        });

        // City Generator
        generators.add(new TileGenerator() {
            @Override
            public Tile generate(List<Tile> generatedTiles, Tile tile, int x, int y, Random random) {
                if (tile.getBiome() != Biome.PLAINS
                        && tile.getBiome() != Biome.DESERT) {
                    // Cities can only spawn on grassland or desert
                    return tile;
                }
                if (tile.getStructure() != null) {
                    return tile;
                }
                for (Tile existingTile : generatedTiles) {
                    if (existingTile.getStructure() == null
                            || existingTile.getStructure().getType() != StructureType.CITY) {
                        continue;
                    }
                    if (Math.abs(existingTile.getArrayX() - x) <= 5 && Math.abs(existingTile.getArrayY() - y) <= 5) {
                        return tile;
                    }
                }
                if (random.nextInt(100) <= 40) {
                    tile.setStructure(new StructureCity(random.nextInt(5)));
                }
                return tile;
            }
        });

        //treeGenerator
        generators.add(new TileGenerator() {
            @Override
            public Tile generate(List<Tile> generatedTiles, Tile tile, int x, int y, Random random) {
                if (tile.getBiome() != Biome.PLAINS) {
                    // Trees can only spawn on grassland
                    return tile;
                }
                if (tile.getStructure() != null) {
                    return tile;
                }
                if (random.nextInt(100) <= 80) {
                    tile.setStructure(new Structure(StructureType.FOREST));
                }
                return tile;
            }
        });

        return generators;
    }

    private void setupUserInterface() {
        stage.getActors().clear();

        UILabel label;
        if (GameManager.instance.server.isHost()) {
            label = new UILabel(50, 100, 300, 300, 32, "Generating the Map...");
        } else {
            label = new UILabel(50, 100, 300, 300, 32, "The Host is generating the Map...");
        }
        stage.addActor(label.getLabel());
    }

    @Override
    public void create() {
        batch = new SpriteBatch();
        font = new BitmapFont();
    }

    @Override
    public void show() {
        super.show();

        System.out.println("Showing generator");

        if (GameManager.instance.server == null) {
            GameManager.instance.playOffline();
        }

        setupUserInterface();

        if (!GameManager.instance.server.isHost()) {
            return;
        }

        /*
         * Start creating the world
         */

        final MapGenerator mapGenerator = new MapGenerator(20, 20, 3);
        List<TileGenerator> Biomes = setupBiomeGenerator(mapGenerator);
        for(TileGenerator generator : Biomes)
            mapGenerator.getTileGeneratorList().add(generator);

        mapGenerator.setCallback(new GeneratorCallback() {
            @Override
            public void generatorFinished() {

                try {
                    Thread.sleep(300);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                final HexMap hexMap = new HexMap(mapGenerator.getSizeX(), mapGenerator.getSizeY());
                hexMap.setTiles(mapGenerator.getGeneratedTiles());

                Map<UUID, String> userColors = new HashMap<>();
                for (UUID uuid : GameManager.instance.server.getSessionData().PlayerList.keySet()) {
                    userColors.put(uuid,
                            GameManager.instance.server.getSessionData().PlayerList.get(uuid).getSecond().toString());
                }

                JsonHexMap jsonHexMap = new JsonHexMap(hexMap.getTiles(), userColors);
                PacketMapUpdate packetMapUpdate = new PacketMapUpdate(jsonHexMap.toJson());
                System.out.println("sending mapupdate " + packetMapUpdate.getRawMapData());

                stage.getActors().clear();
                stage.addActor(
                        new UILabel(50, 100, 300, 300, 32, "Waiting for players...").getLabel()
                );

                if (GameManager.instance.server.isOfflineGame()) {
                    MapManager.getInstance().setCurrentHexMap(hexMap);
                    ScreenManager.getInstance().setCurrentScreen(ScreenType.GAME);
                } else {
                    GameManager.instance.server.send(packetMapUpdate);
                }
            }
        });

        mapGenerator.startGenerating();
    }

    @Override
    public void render(float delta) {
        ScreenManager.getInstance().clearScreen(0.2f, 0.25f, 0.35f);
        batch.begin();
        font.draw(batch, "Generator", 20, 20);
        batch.end();
        stage.draw();

        GameManager.instance.server.callEvents();
    }

    @Override
    public void pause() {

    }

    @Override
    public void resume() {

    }

    @Override
    public void dispose() {
        shapeRenderer.dispose();
        font.dispose();
        stage.dispose();
        batch.dispose();
    }
}
